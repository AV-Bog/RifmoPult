# Архитектура приложения Rifmopult

Данный документ описывает техническую архитектуру мобильного приложения **Rifmopult** — поэтического редактора с функциями подбора рифм, подсчёта слогов и интерактивного редактирования. Проект реализован на языке **Kotlin** в среде **Android Studio** с использованием официальных компонентов **Android Jetpack**.

---

## 1. Общая архитектурная модель

Приложение построено по **двухслойной архитектуре** с чётким разделением:

- **View-слой**: реализован через `Activity` (`NotesActivity`, `NoteEditActivity`) и XML-разметку. Отвечает за отображение, обработку пользовательского ввода и управление UI-состоянием.
- **Model-слой**: инкапсулирует данные и бизнес-логику, полностью независим от UI.

Хотя проект не использует канонический паттерн **MVVM** (отсутствует класс `ViewModel`), он применяет ключевые практики современной Android-разработки:
- безопасная асинхронность через `lifecycleScope` и корутины,
- типобезопасная работа с данными через **Room**,
- разделение модели данных и UI-модели.

---

## 2. Слои данных и их взаимодействие

### 2.1. Модель данных

| Компонент                          | Назначение                                                                                                                         |
|------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| `Note`                             | UI-модель: используется везде в интерфейсе (`Activity`, адаптеры, `Intent`). Реализует `Serializable` для передачи между экранами. |
| `NoteEntity`                       | Сущность Room: аннотирована как `@Entity`, представляет строку в таблице SQLite. Используется только внутри Room.                  |
| Утилиты (`toEntity()`, `toNote()`) | Функции преобразования между слоями. Обеспечивают чёткое разделение ответственности и предотвращают утечку деталей Room в UI.      |

**Преимущества такого разделения:**
- независимость UI от деталей хранения,
- возможность изменения структуры БД без влияния на логику отображения,
- безопасная сериализация данных.

### 2.2. Хранилище данных

- **Библиотека**: **Room Database** поверх SQLite.
- **DAO**: `NoteDao` предоставляет типобезопасный интерфейс:

```kotlin
@Query("SELECT * FROM notes ORDER BY date DESC")
suspend fun getAllNotesSortedByDateDesc(): List<NoteEntity>

@Insert(onConflict = OnConflictStrategy.REPLACE)
suspend fun insertNote(note: NoteEntity)
```

Все операции выполняются в фоновом потоке через `suspend`-функции, исключающие блокировку UI.

## 3. Ключевые UX-механизмы и их реализация

### 3.1. Подсчёт и отображение слогов

- **Логика**: подсчёт по количеству русских гласных (`аеёиоуыэюя`).
- **Отображение**: вспомогательный `TextView` (`syllableOverlay`), синхронизированный с основным редактором.
- **Очистка**: при сохранении, отправке и сравнении изменений текст фильтруется регулярным выражением `\s*·[0-9]+\s*$`, что гарантирует работу только с чистым текстом.

### 3.2. История изменений (Undo/Redo)

- **Структура**: стек состояний на основе `MutableList<NoteState>`.
- **Состояние**: `data class NoteState(val title: String, val content: String)`.
- **Автосохранение**: debounce-механизм с задержкой 1500 мс.
- **Ограничение**: максимальный размер истории — 20 состояний.
- После отмены и новой правки «будущая» ветка истории обрезается — поведение соответствует стандартным текстовым редакторам.

### 3.3. Drag-and-Drop рифм

- **Источник данных**: внешний парсер `RifmeNetParser.fetchRhymes(word)`.
- **UI**: отображение в `FlexboxLayout` внутри `PopupWindow`.
- **Взаимодействие**:
    - распознавание долгого нажатия через `ViewConfiguration.getLongPressTimeout()`,
    - перетаскивание через вспомогательный `PopupWindow` с динамическим позиционированием,
    - вставка в позицию курсора с учётом пунктуации и пробелов.

### 3.4. Навигация между экранами

Реализована через **Activity Result API**:

```kotlin
private val noteEditLauncher = registerForActivityResult(
    ActivityResultContracts.StartActivityForResult()
) { result -> handleNoteEditResult(result) }
```

Обеспечивает типобезопасную передачу результата (`Note` или сигнал удаления) без использования устаревшего `startActivityForResult()`.

## 4. Тестирование и CI

**Юнит-тесты (JUnit 4):**
- Проверка логики подсчёта слогов,
- Корректность очистки подсказок (`stripSyllableHints`),
- Логика определения наличия изменений (`shouldSaveNote`),
- Работа флага даты модификации.

**CI/CD**: настроен GitHub Actions для автоматической проверки:
- сборка debug-версии (`./gradlew assembleDebug`),
- запуск всех модульных тестов (`./gradlew test`).

## 5. Зависимости и инструменты

| Компонент           | Версия / Назначение                     |
|---------------------|------------------------------------------|
| Kotlin              | 1.9+                                     |
| AndroidX Room       | Типобезопасная работа с SQLite           |
| AndroidX Lifecycle  | `lifecycleScope` для корутин             |
| FlexboxLayout       | Отображение рифм в панели                |
| Coroutines          | Асинхронность без колбэков               |

## Заключение

Архитектура **Rifmopult** обеспечивает:

- **Надёжность**: защита от сохранения/отправки визуальных артефактов (подсказок),
- **Расширяемость**: чёткое разделение данных и UI позволяет легко добавлять новые функции,
- **Сопровождаемость**: каждый сложный механизм изолирован и покрыт тестами.